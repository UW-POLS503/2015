---
title: "POLS 503: Problem Set 3"
author: "Jeffrey B. Arnold, Christopher Adolph"
date: "April 30, 2015"
output:
  html_document:
    css: "custom.css"
    pandoc_options: [
    ]
---

$$
\DeclareMathOperator{\cor}{cor}
\DeclareMathOperator{\cov}{cov}
\DeclareMathOperator{\sd}{sd}
\DeclareMathOperator{\se}{se}
\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\quantile}{quantile}
$$


```{r knitr_opts, echo = FALSE, message = FALSE, results = 'hide'}
library("knitr")
set.seed(135125)
opts_chunk$set(cache = TRUE, autodep = TRUE, cache.extra = rand_seed,
               error = TRUE)
```
```{r load,message = FALSE, echo = FALSE}
library("MASS")
library("ggplot2")
library("dplyr")
library("broom")
library("assertthat")
library("tidyr")
library("pols503")
```
```{r external,cache = FALSE, echo=FALSE}
read_chunk("hw3-functions.R")
```

# Instructions and Introduction

The purpose of this homework is to provide a guided, hands-on tour through the properties of the least squares estimator, especially under common violations of the Gauss Markov assumptions.
We will work through a series of programs which use simulated data --- i.e., data created with known properties --- to investigate how these violations affect the accuracy and precision of least squares estimates of slope parameters.
Using repeated study of simulated datasets to explore the properties of statistical models is called Monte Carlo experimentation.
Although you will not have to write much R code, you will need to read through
the provided programs carefully to understand what is happening.

Monte Carlo experiments always produce the same results as analytic proofs for the specific case considered.
Each method has advantages and disadvantages: proofs are more general and elegant, but are not always possible.
Monte Carlo experiments are much easier to construct and can always be carried out, but findings from these experiments only apply to the specific scenario under study.
Where proofs are available, they are generally preferable to Monte Carlo experiments, but proofs of the properties of more complicated models are sometimes impossible or impractically difficult.
This is almost always the case for the properties of models applied to small samples of data.
Here, we use Monte Carlo not out of necessity but for pedagogical purposes, as a tool to gain a more intuitive and hands-on understanding of least squares and its properties.

1. Create a new R project for this homework named `hw3` and load that project.
2. Do your analyses in an R markdown document based off of [hw3-template.Rmd](hw3-template.Rmd)
2. Download [hw3-functions.R](hw3-functions.R) and save in to your project directory.
3. Submit a zipped file of the directory with your R project through Canvas. This should contain all the materials for another person to run your R Markdown fil  This should contain:

    - The R project (`.Rproj`) file
	  - The R Markdown document (`.Rmd`) of your analyses
	  - An HTML document (`.html`) compiled from your R Markdown document.
	  - Any data or other files neede to run the analyses in your R Markdown doceument.

4. Your R Markdown file should follow the guidance from [here](http://pols503.github.io/pols_503_sp15/r_markdown_assignments.html) and your R code should follow the guidelines [here](http://pols503.github.io/pols_503_sp15/r_best_practices.html).
5. Turn in a paper copy of the document compiled from the analyses at lab.
6. You can work together on this but you should each turn in your own assignments and write up your work separately.
   Include the names of your collaborators on your assignment.

# Setup

This assignment has some non-trivial computation.
The following code sets the knitr options to cache the results of computations, so
that any computations that do not change are not rerun.
See RStudio's help on [Authoring R Code Chunks](http://rmarkdown.rstudio.com/authoring_rcodechunks.html#caching) for more information about what this is doing.
```{r echo = TRUE, eval = FALSE}
<<knitr_opts>>
```

This will use the standard [Hadleyverse](http://blog.revolutionanalytics.com/2015/03/hadleyverse.html) packages that we've been using in this course (**ggplot2**, **dplyr**, **tidyr**, **broom**).
A few of the functions will use **assertthat**, which contains functions to test for errors in functions.
Finally, it will use a function from a package written for this course, **pols503**.

```{r eval=FALSE}
<<load>>
```
If you do not have **pols503** installed you need **devtools** installed, and then run
```{r r-pols503,eval = FALSE}
devtools::install_github("POLS503/r-pols503")
```
Additionally we will use some functions from **MASS** and **car**, but we will not load them since they contain some function names that conflict with those in packages that we are using.

You will need to include the code for the functions defined in this problem set ---  `sdcor2cov`, `summarize_sims`, `sim_lin_norm`, etc. --- for your R Markdown file to run.
However, to keep your output more concise, hide the code for these functions by using the code chunk option `echo = FALSE`.

# Simulation Example

All of the simulations in this assignment will follow the same structure:

1. Define a population
2. Repeat $m$ times:

    1. Draw a sample from the population
    2. Run OLS on that sample
    3. Save statistics from the regression on that sample.

3. Compare the distributions of the sample statistics to see how well OLS recovers
    the parameters of the population.

In this section, we will work through an example in which the population satisfies
all the Gauss-Markov assumptions and we run a correctly specified regression on the
samples drawn from that population.
In particular, for a fixed $x$, the population model is
$$
\begin{aligned}[t]
Y_i &= \beta_0 + \sum_{j = 1}^k \beta_j x_{i,j} + \epsilon_i \\
\epsilon_i & \sim N(0, \sigma^2)
\end{aligned}
$$
And the OLS regression which will be run is
$$
\begin{aligned}[t]
y_i &= \hat\beta_0 + \sum_{j = 1}^k \hat\beta_j x_{i,j} + \hat\epsilon_i \\
\hat\sigma^2 &= \frac{\sum \hat\epsilon_i }{n - k - 1}
\end{aligned}
$$
In this case, the regression run on the samples has the correct specification, but that will not necessarily be true for other examples.

In this section, we will proceed in two steps.

1. Write code to generate a single sample and run OLS on it.
2. Generalize that code by

    a. Putting it in a loop to be able to draw many samples
    b. Putting it in a function to make it easy to change parameters of the simulation.

## Single Iteration

### Drawing $X$

First, we need to generate some values of $X$ that we will use in the samples.
Recall that the sampling distributions of OLS coefficients and the Gauss-Markov theorem are defined for a fixed $X$.[^randomx]
So, we will randomly generate data for the covariates, but use the same values of the covariates for all samples from $Y$.
Although linear regression does not require covariates to be distributed multivariate normal, we will generate $X$ by drawing a sample of size $n$ from a multivariate normal distribution with mean $\mu_X$ and covariance matrix $\Sigma_X$.
$$
X_i \sim N(\mu_X, \Sigma_X) \text{ for $i = 1, \dots, n$.}
$$
Since covariance matrices are not particularly intuitive, so it may be easier to decompose the covariance into a correlation matrix and the standard deviations of the variables.
A covariance matrix, $\Sigma$ can be decomposed into a standard deviation $s$ and a correlation matrix $R$,
$$
\Sigma = S R S
$$
where $S$ is a diagonal matrix with the standard deviations $s$ on its diagonal.
The following function will make that calculation simpler.
```{r sdcor2cov}
```

In this example, we will use a sample of size $n = 1024$, with $k = 3$ variables drawn from a multivariate normal distribution with mean $\mu_X = (0, 0, 0)$, standard deviations of $s_X = (1, 1, 1)$, and independent variables,
$$
R_X = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}
$$
This is equivalent to sampling each variable independently from a standard normal distribution.
```{r}
n <- 1024
mu_X <- rep(0, 3)
s_X <- rep(1, 3)
R_X <- diag(3)
Sigma_X <- sdcor2cov(s_X, R_X)
```
We draw the sample using the **MASS** function `mvrnorm`,
```{r}
X <- mvrnorm(n, mu_X, Sigma_X, empirical = TRUE)
```
The option `empirical = TRUE` is used to make sure that although $X$ is randomly sampled,
it is adjusted to so that the sample mean and covariance are equal to $\mu_X$ and $\Sigma_X$,
```{r}
round(cor(X), 1)
round(apply(X, 2, mean), 1)
```

### Drawing Y

After defining $X$, we need values of $\beta$ and $\sigma$ to draw samples from $Y$.

For this example, set the true parameters of the model so that the intercept is 0, and the slope coefficients are all 1.
```{r}
beta <- c(0, 1, 1, 1)
```
and set the standard deviation of the regression errors such that that the $R^2$ of the regression is approximately 0.5
```{r}
sigma <- 1.7
```
Calculate the expected value of the outcome conditional on the covariates, $E(Y | X)$,
```{r}
mu_y <- cbind(1, X) %*% beta
```
The expression `cbind(1, X)` adds a column of 1s as an intercept in the regression to the covariates in $X$.
Then sample the errors, $\epsilon \sim N(0, \sigma^2)$,
```{r}
epsilon_y <- rnorm(n, mean = 0, sd = sigma)
```
Now combine the systematic component, $E(Y | X)$, and stochastic component, $\epsilon$, to generate the values of $y$ in the sample,
```{r}
y <- mu_y + epsilon_y
```

### Sample Regression

Now that we have a sample, we will run an OLS regression on it in order to estimate the parameters of the population,
```{r}
mod <- lm(y ~ X)
```
We will use the `tidy` function from the **broom** package convert the coefficients, standard errors, p-values, and t-values into a data frame.
This will be especially useful when storing the results from many simulations.
```{r}
mod_df <- tidy(mod)
```
The function `tidy` does not include a heteroskedasticity consistent standard error, and we would like to compare that to the classical standard error in some simulations.
We will use the function `hccm` from the **car** package to calculate the heterorskedasticity robust standard error.
```{r}
mod_df[["std.error.robust"]] <- sqrt(diag(car::hccm(mod)))
```

The coefficients of the OLS regression on the parameter should be similar to, but not exactly, those of the population from which it was drawn.
```{r}
mod_df
```

## Multiple iterations

We want to repeat this many times in order to generate a sampling distribution of statistics of interest in order to evaluate how well they work as estimators.
We will do this by (1) wrapping the code from the previous section in a for loop, so we can repeat the simulations many times, and (2) put it all in a function, so that we can easily change the inputs.

Thus, we will define a function, named `sim_lin_norm`.
The code for this function is in the chunk below.
The function itself takes several arguments

`iter`

:    The number of iterations to run / samples to draw.

`n`

:    The number of observations

`mu_X`

:    The means of the covariates in $X$. The number of covariates do not need to
     be specified as it is inferred from the length of `mu_X`.

`s_X`

:    The standard deviations of the covariates in $X$.

`R_X`

:    The correlation matrix for the covariates in $X$.

`beta`

:    The coefficient vector, $\beta$.

`sigma`

:    The standard deviations of the regression errors, $\sigma$.


This function returns a data frame with the results of all the simulations.
Each row is a coefficient (column `term`) for a simulation (column `.iter`)

```{r sim_lin_norm}
```
Now we will draw samples using the values that we used before and look at the results.
```{r sim0}
iter <- 4096
sim0 <- sim_lin_norm(iter, n, mu_X, s_X, R_X, beta, sigma)
head(sim0)
```
With all the samples, we can summarize the results and compare them to the population parameters to evaluate how well OLS works.
The following function, `summarize_sim` takes a data frame generated by the simulation function and a vector of the original parameters, and generates a summary data frame with one row per coefficient.
Its arguments are

`.data`

:    A data frame of a simulation produced by one of the functions in this problem set.

`beta`

:    The true values of the population parameters $\beta$.

```{r summarize_sim}
```
Using the previous results, the summary is
```{r sim0_summary}
sim0_summary <- summarize_sim(sim0, beta)
sim0_summary
```

In these simulations we will generally, but not exclusively, be concerned with the bias and efficiency of the estimates.

First, compare the average value of $\hat\beta$ to the population parameters $\beta$.
This is what is nice about simulations, we know what the correct answer should be!
```{r}
select(sim0_summary, estimate_mean, beta_true)
```
If an estimator is unbiased, then the mean of its sampling distribution should be equal to the true parameter value.
Note that these may not be exactly the same due to the randomness from taking a sample; this is called Monte Carlo error.

Second, we are interested in the standard deviation of the $\hat\beta$ estimates,
We will often be interested in how the standard deviation of the estimator changes with inputs to the simulation.
```{r}
select(sim0_summary, estimate_sd)
```

Third, we will be interested in whether the standard error, which is sample estimate of the standard deviation of the sampling distribution, is a good estimate of the actual sampling distribution of $\hat\beta$.
The mean of the classical standard errors of the simulations are in column `se_mean`.
The column `se_robust_mean` contains the means of the heteroskedasticity robust standard errors.
```{r}
select(sim0_summary, estimate_sd, se_mean, se_robust_mean)
```
If `se_mean` (`se_robust_mean`) is not equal (or very close) to the `estimate_sd`, then the standard errors (robust standard errors) calculated from samples are biased estimates of the standard deviation of the sampling distribution of $\hat{\beta}$.

Those are the most common questions we will consider in the simulations,
but some simulations may consider other questions.

*Hint:* For the problems which ask for multiple simulations you can automate the repitition using a recipe similar to the one used in the function.
(1) Create a list to store the simulations.
(2) Put the simulations in a for loop that runs it for each value of $n$ or whatever is changing in that problem.
Save the results of `summarize_sim` to the list.
Remember to add a column for the parameter that is changing between simulations.
(3) Stack the dataframes in the list using `bind_rows`. 

# Problems {#problems}

The problems of this assignment will use various simulations similar to the one in the previous section.
For all simulations use `iter = 4096`. 
If this is taking too long you can reduce the number of iterations.

## Linear Normal Model with Homoskedasticity

In this problem, we will use `sim_lin_norm` to understand how OLS recovers parameters when the population meets the Gauss-Markov assumptions.
$$
\begin{aligned}[t]
Y_i &= 0 + 1 \cdot x_{1,i} + 1 \cdot x_{2,i} + 1 \cdot x_{3,i} + \epsilon_i \\
\epsilon_i &\sim N(0, \sigma^2) \\
\sigma &= 1.7
\end{aligned}
$$
The covariates, $X$, are independent, with means, $\mu_X = (0, 0, 0)$, and standard deviations, $s_X = (1, 1, 1)$. The sample size $n$ will vary with simulation.

Run several simulations with `sim_lin_norm` varying the sample size to determine how sample size affects the following. Use $n = \{8, 64, 512, 1024 \}$.

- The bias of each $\hat{\beta}_j$?
- The variance of $\hat{\beta}_j$?
- The bias of the standard error of each $\hat{\beta}_j$?
- The bias of the robust standard error of each $\hat{\beta}_j$?

## Correlated Variables

In the previous problem, the covariates were assumed to be independent.
Now, we will evaluate the properties of OLS estimates when covariates are correlated.
As before, the population is
$$
\begin{aligned}[t]
Y_i &= 0 + 1 \cdot x_{1,i} + 1 \cdot x_{2,i} + 1 \cdot x_{3,i} + \epsilon_i \\
\epsilon_i &\sim N(0, \sigma^2) \\
\sigma &= 1.7
\end{aligned}
$$
In this problem keep $\mu_X = (0, 0, 0)$ and $s_X = (1, 1, 1)$, but $R_X$ will differ between simulations to allow for different levels of correlation between   $x_1$ and $x_2$.
The covariate $x_3$ is independent of the other covariates, $\cor(x_1, x_3) = \cor(x_2, x_3) = 0$.
Use $n = 1024$ for all simulations.

Simulate using `sim_lin_normal` with the following levels of correlation between $x_1$ and $x_2$: 0, 0.5, 0.95, -0.5, -0.95.
Based on the results of those simulations, how does $\cor(x_1, x_2)$ affect the following?

- The bias of each $\hat{\beta}_j$?
- The variance of $\hat{\beta}_j$?
- The bias of the standard error of each $\hat{\beta}_j$?
- The bias of the robust standard error of each $\hat{\beta}_j$?

Remember to consider the effects of correlation on *all* the estimates: $\hat{\beta}_1$, $\hat{\beta}_2$, and $\hat{\beta}_3$.

## Collinearity

Use the same settings in the previous question, but set $\cor(x_1, x_2) = 1$.
What happens?
Why?

## P-values, Type I and II errors

In this problem we will explore how $p$-values and Type I and II errors vary between samples.
Use this population model for the simulations:
$$
\begin{aligned}[t]
Y_i &= 0 + 0 \cdot x_{1,i} + 0.1 \cdot x_{2,i} + 0.5 \cdot x_{3,i} + 1 \cdot x_{4,i} + \epsilon_i \\
\epsilon_i &\sim N(0, 1.9^2)
\end{aligned}
$$
The covariates, $X$, are independent, with means, $\mu_X = (0, 0, 0)$, and standard deviations, $s_X = (1, 1, 1)$.
Use $n = 1024$.
<!-- \sigma^2 = 1.9 is R^2 of approx 0.25 -->

- For each parameter, plot the distribution of $p$-values across iterations.
  Describe the densities.
- For each parameter, calculate the proportion of $p$-values less than 0.05 for each parameter.
  Suppose a null hypothesis of $H_0: \beta_i = 0$ and an alternative hypothesis of $H_a: \beta_i > 0$.
  For which parameters is $H_0$ true, for which parameters is $H_a
  What is the probability of a Type I or Type II error for each parameter.
- For each parameter, plot the distribution of its estimates *conditional* on it being significant at $p < 0.05$.
  How does the sampling distribution conditional on statistical significance relate to the unconditional sampling distribution?
- Repeat each of those analyses using a smaller sample size, $n = 32$, and a larger sample size $n = 1024$.
  What changes, if anything?

## Omitted Variable Bias

The following function, `sim_lin_norm_omitted` samples from a linear, normal model with homoskedastic errors, but allows you to run a misspecified regression on the samples by omitting variables.
The arguments to this function are the same as `sim_lin_norm` except for

`omit`

:    A vector of integers of the columns to omit from X when estimating the sample regression.

```{r sim_lin_norm_omitted}
```

The population is
$$
\begin{aligned}[t]
Y_i &= 0 + 1 \cdot x_{1,i} + 1 \cdot x_{2,i} + 1 \cdot x_{3,i} + \epsilon_i \\
\epsilon_i &\sim N(0, \sigma^2) \\
\sigma &= 1.7
\end{aligned}
$$
The covariates, $x$, have mean $\mu_X = (0, 0, 0)$ and standard deviation $s_X = (1, 1, 1)$ and correlation
$$
R_X =
\begin{bmatrix}
1 & 0 & \rho_{1,3} \\
0 & 1 & 0 \\
\rho_{1,3} & 0 & 1
\end{bmatrix}
$$
In all simulations, $(x_1, x_2)$ and $(x_2, x_3)$ are uncorrelated.
The correlation between $x_1$ and $x_3$ will vary between simulations.
In all simulations, the sample regression will only include $x_1$ and $x_2$:
$$
y_i = \hat\beta_0 + \hat\beta_1 x_{1,i} + \hat\beta_2 x_{2,i} + \hat\epsilon_i
$$
To omit the 3rd variable, set `omit = 3` in `sim_lin_norm_omitted`.
Use $n = 1024$ for all simulations.

Consider the following values of $\rho_{1,3}$: 0, 0.1, 0.7, -0.7, 0.99, -0.99.
How does the correlation of variables affect:

- The bias of each $\hat{\beta}_j$?
- The variance of $\hat{\beta}_j$?
- The bias of the standard error of each $\hat{\beta}_j$?
- The bias of the robust standard error of each $\hat{\beta}_j$?

## Heteroskedasticity

In this problem, we will explore how heteroskedasticity affects OLS estimates.
The function `sim_lin_norm_hereosked` will simulate from that population, but estimate OLS regressions on each sample that do not model that heteroskedasticity.
It samples from a population model with heteroskedasticity:
$$
\begin{aligned}
Y_i &= \beta_0 + \sum_{j = 1}^k x_{j,i} + \epsilon_i \\
\epsilon_i &\sim N(0, \sigma^2_i) \\
\log \sigma_i^2 &= \gamma_0 + \sum_{j = 1}^k \gamma_j x_{j,i}
\end{aligned}
$$
Note that $\sigma^2$ varies with each observation, and is a function of $x$.

The arguments for it are the same as `sim_lin_norm` except for

`gamma`

:    A vector of coefficients for $\log \sigma^2 = \gamma_0 + \gamma_1 x_1 + \dots + \gamma_k x_k$. Like `beta` it should have length `k + 1`.

```{r sim_lin_norm_heterosked}
```

In these simulations, the population model is
$$
\begin{aligned}[t]
Y_i &= 0 + 1 \cdot x_1 + 1 \cdot x_2 \epsilon_i \\
\epsilon_i &\sim N(0, \sigma^2_i) \\
\log \sigma_i^2 &= 1.5 + \gamma_1 x_1 + 0 \cdot x_2
\end{aligned}
$$

We will run several simulations with different values of $\gamma_1$ to vary to heteroskedasticity:

- $\gamma_1 = 0$: no heteroskedasticity
- $\gamma_1 = 0.3$: low heteroskedasticity, $\max(\sigma^2_i) / \min(\sigma^2_i) \approx 2.7$.
- $\gamma_1 = 0.7$ high heteroskedasticity, $\max(\sigma^2_i) / \min(\sigma^2_i) \approx 24$.

Before running the simulation draw a single sample of $y$ from a population with each of those values of $\gamma_1$.
You should be able to extract the relevant code from `sim_lin_norm_heterosked`.
Regress $y$ on $x_1$ and $x_2$ and plot the residuals of this regression against $x_1$.

Run `sim_lin_norm_heterosked` for each of those values of $\gamma_1$.
How does heteroskedasticity affect

- the bias of each $\hat{\beta}_j$?
- the variance of $\hat{\beta}_j$?
- the bias of the standard error of each $\hat{\beta}_j$?
- the bias of the robust standard error of each $\hat{\beta}_j$?

Remember to consider how heteroskedasticity in $x_1$ affects the estimates of heteroskedasticity in $x_2$.

## Truncated Dependent Variable

This problem considers what happens when there is a truncated dependent variable.
This is also called sampling on the dependent variable, which is a research design problem not unknown to political science research.[^samplingdv]

The population is a linear normal model with homoskedastic errors.
$$
\begin{aligned}[t]
Y_1 &= \beta_0 + \beta_1 x_{1,i} + \dots + \beta_k x_{k,i} + \epsilon_i \\
\epsilon_i &\sim N(0, \sigma^2)
\end{aligned}
$$
However, in each sample, all $y_i$ which are less than a quantile $q$ are dropped before the regression is estimated.
$$
\begin{aligned}[t]
y_i = \beta_0 + \hat\beta_1 x_{1,i} + \dots + \hat\beta_k x_{k,i} + \hat\epsilon \\ \text{if $y_i \geq \quantile(y, q)$}
\end{aligned}
$$
where $\quantile(y, q)$ is the $q$th quantile of $y$.
For example, if $q = 0.5$, all $y_i$ that are less than the median of $y$ (the bottom 50%) are dropped.

The function `sim_lin_norm_truncated`, is similar to the `sim_lin_norm` function except for the argument

`truncation`

:    The quantile of truncation. All sampled $y_i$ with values less than that quantile are dropped before the regression is run.
     The default value `truncation = 0.5` means all values of $y$ less than the median are dropped before running the regression.


```{r sim_lin_norm_truncated}
```

For this problem, use only a single covariate, with $\mu_X = 0$,$s_X = 1$, and $R_X = 1$.
Let $\beta = (0, 1)$ and $\sigma = 1$.
Estimate the regression only on those $y_i$ greater than the median of $y$.

Before running simulations, draw a single sample of a linear normal model with homoskedastic errors. 
To do this, you should be able to adapt the code from `sim_lin_normal_truncated`.
Create a scatter plot with the OLS line for all $y$, and a another plot with only those $y$ less than the median of $y$.
How idoes the OLS line estimated on the truncated data differ from the one estimated on the untruncated data.

Run several simulations with `sim_lin_normal_truncated` and vary the sample size.
How does the sample size affect the following:

- The bias of each $\hat{\beta}_j$?
- The variance of $\hat{\beta}_j$?

In particular, if we gather more data but $y$ is truncated, does it decrease the bias in $\hat{\beta}$?

[^randomx]: Although the statistical theory of OLS works (thankfully) for random $X$,
    as long as certain conditions are met. See Fox (2nd ed.), Ch 9.6.

[^samplingdv]: See Ashworth, Scott, Joshua D. Clinton, Adam Meirowitz, and Kristopher W. Ramsay. 2008. ``Design, Inference, and the Strategic Logic of Suicide Terrorism.'' *American Political Science Review() 102(02): 269â€“73. <http://journals.cambridge.org/article_S0003055408080167>

* * *

Derived from of Christopher Adolph, "Problem Set 3", *POLS/CSSS 503*, University of Washington, Spring 2014. <http://faculty.washington.edu/cadolph/503/503hw3.pdf>. Used with permission.

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
