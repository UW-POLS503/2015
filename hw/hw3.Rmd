---
title: "POLS 503: Homework 3"
author: "Jeffrey B. Arnold, Christopher Adolph"
date: "April 30, 2015"
output:
  html_document:
    css: "custom.css"
    pandoc_options: [
    ]
---

$$
\DeclareMathOperator{\cor}{cor}
\DeclareMathOperator{\cov}{cov}
\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\quantile}{quantile}
$$

```{r results='hide', echo = FALSE, message = FALSE}
knitr::opts_chunk$set(error = TRUE)
```


The purpose of this homework is to provide a guided, hands-on tour through the properties of the least squares estimator, especially under common violations of the Gauss Markov assumptions. 
We will work through a series of programs which use simulated data --- i.e., data created with known properties --- to investigate how these violations affect the accuracy and precision of least squares estimates of slope parameters. 
Using repeated study of simulated datasets to explore the properties of statistical models is called Monte Carlo experimentation.
Although you will not have to write much R code, you will need to read through
the provided programs carefully to understand what is happening.

Monte Carlo experiments always produce the same results as analytic proofs for the specific case considered.
Each method has advantages and disadvantages: proofs are more general and elegant, but are not always possible.
Monte Carlo experiments are much easier to construct and can always be carried out, but findings from these experiments only apply to the specific scenario under study.
Where proofs are available, they are generally preferable to Monte Carlo experiments, but proofs of the properties of more complicated models are sometimes impossible or impractically difficult.
This is almost always the case for the properties of models applied to small samples of data.
Here, we use Monte Carlo not out of necessity but for pedagogical purposes, as a tool to gain a more intuitive and hands-on understanding of least squares and its properties.

# Setup 

This assignment has some non-trivial computation.
The following code sets the knitr options to cache the results of computations, so 
that any computations that do not change are not rerun.
See RStudio's help on [Authoring R Code Chunks](http://rmarkdown.rstudio.com/authoring_rcodechunks.html#caching) for more information about what this is doing.
```{r setup, echo = TRUE, eval = FALSE}
knitr::opts_chunk$set(cache = TRUE)
```

This will use the standard [Hadleyverse](http://blog.revolutionanalytics.com/2015/03/hadleyverse.html) packages that we've been using in this course (**ggplot2**, **dplyr**, **tidyr**, **broom**).
A few of the functions will use **assertthat**, which contains functions to test for errors in functions.
Finally, it will use a function from a package written for this course, **pols503**.

```{r message = FALSE}
library("ggplot2")
library("dplyr")
library("broom")
library("assertthat")
library("tidyr")
library("pols503")
```
If you do not have **pols503** installed you need **devtools** installed, and then run
```{r eval = FALSE}
devtools::install_github("POLS503/r-pols503")
```
Additionally we will use some functions from **MASS** and **car**, but we will not load them since they contain some function names that conflict with those in packages that we are using.

# Simulation Example

All of the simulations in this assignment will follow the same structure:

1. Define a population
2. Repeat $m$ times:

    1. Draw a sample from the population
    2. Run OLS on that sample
    3. Save statistics from the regression on that sample.
   
3. Compare the distributions of the sample statistics to see how well OLS recovers
    the parameters of the population.
  
In this section, we will work through an example in which the population satisfies
all the Gauss-Markov assumptions and we run a correctly specified regression on the 
samples drawn from that population.
In particular, for a fixed $x$, the population model is
$$
\begin{aligned}[t]
Y_i &= \beta_0 + \sum_{j = 1}^k \beta_j x_{i,j} + \epsilon_i \\
\epsilon_i & \sim N(0, \sigma^2)
\end{aligned}
$$
And the OLS regression which will be run is 
$$
\begin{aligned}[t]
y_i &= \hat\beta_0 + \sum_{j = 1}^k \hat\beta_j x_{i,j} + \hat\epsilon_i \\
\hat\sigma^2 &= \frac{\sum \hat\epsilon_i }{n - k - 1}
\end{aligned}
$$
In this case, the regression run on the samples has the correct specification, but that will not necessarily be true for other examples.

In this section, we will proceed in two steps. 

1. Write code to generate a single sample and run OLS on it.
2. Generalize that code by

    a. Putting it in a loop to be able to draw many samples
    b. Putting it in a function to make it easy to change parameters of the simulation.

## Single Iteration

### Drawing $X$

First, we need to generate some values of $X$ that we will use in the samples.
Recall that the sampling distributions of OLS coefficients and the Gauss-Markov theorem are defined for a fixed $X$.[^randomx] 
So, we will randomly generate data for the covariates, but use the same values of the covariates for all samples from $Y$.
Although linear regression does not require covariates to be distributed multivariate normal, we will generate $X$ by drawing a sample of size $n$ from a multivariate normal distribution with mean $\mu_X$ and covariance matrix $\Sigma_X$.
$$
X_i \sim N(\mu_X, \Sigma_X) \text{ for $i = 1, \dots, n$.}
$$
Since covariance matrices are not particularly intuitive, so it may be easier to decompose the covariance into a correlation matrix and the standard deviations of the variables. 
A covariance matrix, $\Sigma$ can be decomposed into a standard deviation $s$ and a correlation matrix $R$,
$$
\Sigma = S R S
$$
where $S$ is a diagonal matrix with the standard deviations $s$ on its diagonal.
The following function will make that calculation simpler.
```{r}
sdcor2cov <- function(s, r = diag(length(s))) {
  s <- diag(s, nrow = length(s), ncol = length(s))
  s %*% r %*% s
}
```

In this example, we will use a sample of size $n = 128$, with $k = 3$ variables drawn from a multivariate normal distribution with mean $\mu_X = (0, 0, 0)$, standard deviations of $s_X = (1, 1, 1)$, and independent variables,
$$
R_X = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}
$$
This is equivalent to sampling each variable independently from a standard normal distribution.
```{r}
n <- 128
mu_X <- rep(0, 3)
s_X <- rep(1, 3)
R_X <- diag(3)
Sigma_X <- sdcor2cov(s_X, R_X)
```
We draw the sample using the **MASS** function `mvrnorm`,
```{r}
X <- MASS::mvrnorm(n, mu_X, Sigma_X, empirical = TRUE)
```
The option `empirical = TRUE` is used to make sure that although $X$ is randomly sampled,
it is adjusted to so that the sample mean and covariance are equal to $\mu_X$ and $\Sigma_X$,
```{r}
round(cor(X), 1)
round(apply(X, 2, mean), 1)
```

### Drawing Y

After defining $X$, we need values of $\beta$ and $\sigma$ to draw samples from $Y$.

For this example, set the true parameters of the model so that the intercept is 0, and the slope coefficients are all 1.
```{r}
beta <- c(0, 1, 1, 1)
```
and set the standard deviation of the regression errors such that that the $R^2$ of the regression is approximately 0.5
```{r}
sigma <- 1.7
```
Calculate the expected value of the outcome conditional on the covariates, $E(Y | X)$,
```{r}
mu_y <- cbind(1, X) %*% beta
```
The expression `cbind(1, X)` adds a column of 1s as an intercept in the regression to the covariates in $X$.
Then sample the errors, $\epsilon \sim N(0, \sigma^2)$,
```{r}
epsilon_y <- rnorm(n, mean = 0, sd = sigma)
```
Now combine the systematic component, $E(Y | X)$, and stochastic component, $\epsilon$, to generate the values of $y$ in the sample,
```{r}
y <- mu_y + epsilon_y
```

### Sample Regression

Now that we have a sample, we will run an OLS regression on it in order to estimate the parameters of the population,
```{r}
mod <- lm(y ~ X)
```
We will use the `tidy` function from the **broom** package convert the coefficients, standard errors, p-values, and t-values into a data frame.
This will be especially useful when storing the results from many simulations.
```{r}
mod_df <- tidy(mod)
```
The function `tidy` does not include a heteroskedasticity consistent standard error, and we would like to compare that to the classical standard error in some simulations.
We will use the function `hccm` from the **car** package to calculate the heterorskedasticity robust standard error.
```{r}
mod_df[["std.error.robust"]] <- sqrt(diag(car::hccm(mod)))
```

The coefficients of the OLS regression on the parameter should be similar to, but not exactly, those of the population from which it was drawn.
```{r}
mod_df
```

## Multiple iterations

We want to repeat this many times in order to generate a sampling distribution of statistics of interest in order to evaluate how well they work as estimators.
We will do this by (1) wrapping the code from the previous section in a for loop, so we can repeat the simulations many times, and (2) put it all in a function, so that we can easily change the inputs.

Thus, we will define a function, named `sim_lin_norm`.
The code for this function is in the chunk below. 
The function itself takes several arguments

`m`

:    The number of iterations to run / samples to draw.

`n`

:    The number of observations    

`mu_X`

:    The means of the covariates in $X$. The number of covariates do not need to 
     be specified as it is inferred from the length of `mu_X`.

`s_X`

:    The standard deviations of the covariates in $X$.

`R_X`

:    The correlation matrix for the covariates in $X$.

`beta`

:    The coefficient vector, $\beta$.

`sigma`

:    The standard deviations of the regression errors, $\sigma$.


This function returns a data frame with the results of all the simulations. 
Each row is a coefficient (column `term`) for a simulation (column `.iter`)

```{r}
sim_lin_norm <- function(m, n, mu_X, s_X, R_X, beta, sigma) {
  # Error checking so that bugs are caught quicker :-)
  assert_that(length(s_X) == length(mu_X),
              ncol(R_X) == nrow(R_X),
              ncol(R_X) == length(mu_X),
              length(beta) == (length(mu_X) + 1))
  # Generate an X
  X <- MASS::mvrnorm(n, mu_X, sdcor2cov(s_X, R_X), empirical = TRUE)
  # Create a list to stor the results
  simulations <- list()
  # Create a progress bar because we're impatient
  p <- progress_estimated(m, min_time = 2)
  # Loop over the simulation runs
  for (j in 1:m) {
    # Draw y
    mu <- cbind(1, X) %*% beta
    epsilon <- rnorm(n, mean = 0, sd = sigma)
    y <- mu + epsilon
    # Run a regression
    mod <- lm(y ~ X)
    # Save the coefficients in a data frame
    mod_df <- tidy(mod) %>%
      # Add a column indicating the simulation number
      mutate(.iter = j)
    # Add hetroskedasticity consistent se to the data
    mod_df[["std.error.robust"]] <- sqrt(diag(car::hccm(mod)))
    # Save these results as the next element in the storage list
    simulations[[j]] <- mod_df
    # Update the progress bar
    p$tick()$print()
  }
  # Combine the list of data frames into a single data frame
  bind_rows(simulations)
}

```
Now we will draw 1,024 samples using the values that we used before and look at the results.
```{r}
m <- 1024
sim0 <- sim_lin_norm(m, n, mu_X, s_X, R_X, beta, sigma)
head(sim0)
```
With all the samples, we can summarize the results and compare them to the population parameters to evaluate how well OLS works.
The following function, `summarize_sim` takes a data frame generated by the simulation function and a vector of the original parameters, and generates a summary data frame with one row per coefficient.
Its arguments are

`.data`

:    A data frame of a simulation produced by one of the functions in this problem set.

`beta`

:    The true values of the population parameters $\beta$.

```{r sim_summary}
summarize_sim <- function(.data, beta) {
  ret <- .data %>%
    group_by(term) %>%
    summarize(estimate_mean = mean(estimate),
              estimate_sd = sd(estimate),
              se_mean = sqrt(mean(std.error) ^ 2),
              se_robust_mean = sqrt(mean(std.error.robust) ^ 2),
              n = length(estimate))
  ret[["beta_true"]] <- beta
  ret
}
```
Using the previous results, the summary is 
```{r}
sim0_summary <- summarize_sim(sim0, beta)
sim0_summary
```

In these simulations we will generally, but not exclusively, be concerned with the bias and efficiency of the estimates.

First, compare the average value of $\hat\beta$ to the population parameters $\beta$.
This is what is nice about simulations, we know what the correct answer should be!
```{r error=TRUE}
select(sim0_summary, estimate_mean, beta_true)
```
If an estimator is unbiased, then the mean of its sampling distribution should be equal to the true parameter value.
Note that these may not be exactly the same due to the randomness from taking a sample; this is called Monte Carlo error.

Second, we are interested in the standard deviation of the $\hat\beta$ estimates,
We will often be interested in how the standard deviation of the estimator changes with inputs to the simulation.
```{r}
select(sim0_summary, estimate_sd)
```

Third, we will be interested in whether the standard error, which is sample estimate of the standard deviation of the sampling distribution, is a good estimate of the actual sampling distribution of $\hat\beta$.
The mean of the classical standard errors of the simulations are in column `se_mean`.
The column `se_robust_mean` contains the means of the heteroskedasticity robust standard errors.
```{r}
select(sim0_summary, estimate_sd, se_mean, se_robust_mean)
```
If `se_mean` (`se_robust_mean`) is not equal (or very close) to the `estimate_sd`, then the standard errors (robust standard errors) calculated from samples are biased estimates of the standard deviation of the sampling distribution of $\hat{\beta}$.

Those are the most common questions we will consider in the simulations,
but some simulations may consider other questions.

# Problems {#problems}

The problems of this assignment will use various simulations similar to the one in the previous section 

## Linear Normal Model with Homoskedasticity

In this problem, we will use `sim_lin_normal` to understand how OLS recovers parameters when the population meets the Gauss-Markov assumptions.
$$
\begin{aligned}[t]
Y_i &= 0 + 1 \cdot x_{1,i} + 1 \cdot x_{2,i} + 1 \cdot x_{3,i} + \epsilon_i \\
\epsilon_i &\sim N(0, \sigma^2) \\
\sigma &= 1.7
\end{aligned}
$$
The covariates, $X$, are independent, with means, $\mu_X = (0, 0, 0)$, and standard deviations, $s_X = (1, 1, 1)$. The sample size $n$ will vary with simulation.

Run several simulations with `sim_lin_norm` varying the sample size to determine how sample size affects the following: 

- The bias of each $\hat{\beta}_j$?
- The variance of $\hat{\beta}_j$?
- The bias of the standard error of each $\hat{\beta}_j$?
- The bias of the robust standard error of each $\hat{\beta}_j$?


## Correlated Variables

In the previous problem, the covariates were assumed to be independent.
Now, we will evaluate the properties of OLS estimates when covariates are correlated.
As before, the population is 
$$
\begin{aligned}[t]
Y_i &= 0 + 1 \cdot x_{1,i} + 1 \cdot x_{2,i} + 1 \cdot x_{3,i} + \epsilon_i \\
\epsilon_i &\sim N(0, \sigma^2) \\
\sigma &= 1.7
\end{aligned}
$$
The covariates of $x$ all have $\mu_{x_j} = 0$, and $s_{x_k} = 0$.
The covariates $x_1$ and $x_2$ may be correlated.
The covariate $x_3$ is independent of the other covariates, $\cor(x_1, x_3) = \cor(x_2, x_3) = 0$.
Use $n = 128$ for all simulations.

Consider the following values of correlation between $x_1$ and $x_2$

- $\cor(x_1, x_2) = 0.5$
- $\cor(x_1, x_2) = 0.95$
- $\cor(x_1, x_2) = -0.5$
- $\cor(x_1, x_2) = -0.95$

How does $\cor(x_1, x_2)$ affect the following? 

- The bias of each $\hat{\beta}_j$?
- The variance of $\hat{\beta}_j$?
- The bias of the standard error of each $\hat{\beta}_j$?
- The bias of the robust standard error of each $\hat{\beta}_j$?

Remember to consider the effects on *all* the estimates: $\hat{\beta}_1$, $\hat{\beta}_2$, and $\hat{\beta}_3$.

## Collinearity

Use the same settings in the previous question, but set $\cor(x_1, x_2) = 1$.
What happens?
Why? 

## P-values, Type I and II errors

In this problem we will explore how $p$-values and Type I and II errors vary between samples. In these simulations use the population,
$$
\begin{aligned}[t]
Y_i &= 0 + 0 \cdot x_{1,i} + 0.1 \cdot x_{2,i} + 0.5 \cdot x_{3,i} + 1 \cdot x_{4,i} + \epsilon_i \\
\epsilon_i &\sim N(0, 1.9^2)
\end{aligned}
$$
The covariates, $X$, are independent, with means, $\mu_X = (0, 0, 0)$, and standard deviations, $s_X = (1, 1, 1)$. Use $n = 128$.
<!-- \sigma^2 = 1.9 is R^2 of approx 0.25 -->

- For each parameter, plot the density of its $p$-values from simulations.
  What do they look like?
- For each parameter, calculate the proportion of `p.value < 0.05` for each parameter.
  Suppose the null hypothesis $H_0: \beta_i = 0$ for all parameters.
  What is the probability of a Type I or Type II error for each parameter. 
- For each parameter, plot the distribution of its estimates *conditional* on it being significant at $p < 0.05$. 
  How does the sampling distribution conditional on statistical significance relate to the unconditional sampling distribution? 
- Repeat each of those analyses using a smaller sample size, $n = 32$, and a larger sample
size $n = 1024$. What changes, if anything?

## Omitted Variable Bias

The following function, `sim_lin_norm_omitted` samples from a linear, normal model with homoskedastic errors, but allows you to run a misspecified regression on the samples by omitting variables. 
The arguments to this function are the same as `sim_lin_norm` except for 

`omit`

:    A vector of integers of the columns to omit from X when estimating the sample regression.

```{r}
sim_lin_norm_omitted <- function(m, n, mu_X, s_X, R_X, beta, sigma,
                                 omit = integer(0)) {
  assert_that(length(s_X) == length(mu_X),
              ncol(R_X) == nrow(R_X),
              ncol(R_X) == length(mu_X),
              length(beta) == (length(mu_X) + 1))
  # Generate an X
  k <- length(mu_X)
  X <- MASS::mvrnorm(n, mu_X, sdcor2cov(s_X, R_X), empirical = TRUE)
  # ------
  # NEW: ensure colnames of X are consistent despite omitting some in lm
  colnames(X) <- paste("X", 1:k, sep = "")
  # ------
  simulations <- list()
  p <- progress_estimated(m, min_time = 2)
  for (j in 1:m) {
    mu <- cbind(1, X) %*% beta
    epsilon <- rnorm(n, mean = 0, sd = sigma)
    y <- mu + epsilon
    # ---------
    # NEW: omit columns of X
    # Look up paste and setdiff function to see what they does
    Xomit <- as.data.frame(X)[ , setdiff(1:k, omit)]
    # ~ . means use all variables from `data` on the RHS of the formula
    mod <- lm(y ~ . , data = Xomit)
    # ---------
    mod_df <- tidy(mod) %>%
      mutate(.iter = j)
    mod_df[["std.error.robust"]] <- sqrt(diag(car::hccm(mod)))
    simulations[[j]] <- mod_df
    p$tick()$print()
  }
  # Combine the list of data frames into a single data frame
  bind_rows(simulations)
}
```

The population is
$$
\begin{aligned}[t]
Y_i &= 0 + 1 \cdot x_{1,i} + 1 \cdot x_{2,i} + 1 \cdot x_{3,i} + \epsilon_i \\
\epsilon_i &\sim N(0, \sigma^2) \\
\sigma &= 1.7 
\end{aligned}
$$
The covariates, $x$, have mean $\mu_X = (0, 0, 0)$ and standard deviation $s_X = (1, 1, 1)$ and correlation 
$$
R_X = 
\begin{bmatrix}
1 & 0 & \rho_{1,3} \\
0 & 1 & 0 \\
\rho_{1,3} & 0 & 1
\end{bmatrix}
$$
In all simulations, $(x_1, x_2)$ and $(x_2, x_3)$ are uncorrelated.
The correlation between $x_1$ and $x_3$ will vary between simulations.
In all simulations, the sample regression will only include $x_1$ and $x_2$:
$$
y_i = \hat\beta_0 + \hat\beta_1 x_{1,i} + \hat\beta_2 x_{2,i} + \hat\epsilon_i
$$

Consider the following values of $\rho_{1,3}$: 0.1, 0.7, -0.7, 0.99.
How does the correlation of variables affect:  

- The bias of each $\hat{\beta}_j$?
- The variance of $\hat{\beta}_j$?
- The bias of the standard error of each $\hat{\beta}_j$?
- The bias of the robust standard error of each $\hat{\beta}_j$?

## Heteroskedasticity 

In this problem, we will explore how heteroskedasticity affects OLS estimates.
The function `sim_lin_norm_hereosk` will simulate from that population, but estimate OLS regressions on each sample that do not model that heteroskedasticity.
It samples from a population model with heteroskedasticity:
$$
\begin{aligned}
Y_i &= \beta_0 + \sum_{j = 1}^k x_{j,i} + \epsilon_i \\
\epsilon_i &\sim N(0, \sigma^2_i) \\
\log \sigma_i^2 &= \gamma_0 + \sum_{j = 1}^k \gamma_j x_{j,i}
\end{aligned}
$$
Note that $\sigma^2$ varies with each observation, and is a function of $x$.

The arguments for it are the same as `sim_lin_norm` except for

`gamma`

:    A vector of coefficients for $\log \sigma^2 = \gamma_0 + \gamma_1 x_1 + \dots + \gamma_k x_k$. Like `beta` it should have length `k + 1`.

```{r}
sim_lin_norm_heterosked <- function(m, n, mu_X, s_X, R_X, beta, sigma, gamma) {
  assert_that(length(s_X) == length(mu_X),
              ncol(R_X) == nrow(R_X),
              ncol(R_X) == length(mu_X),
              length(beta) == (length(mu_X) + 1),
              length(gamma) == (length(mu_X) + 1))
  X <- MASS::mvrnorm(n, mu_X, sdcor2cov(s_X, R_X), empirical = TRUE)
  simulations <- list()
  p <- progress_estimated(m, min_time = 2)
  for (j in 1:m) {
    mu <- cbind(1, X) %*% beta
    # ------------ 
    # NEW: variance varies by each observation
    sigma <- sqrt(exp(cbind(1, X) %*% gamma))
    # ------------
    epsilon <- rnorm(n, mean = 0, sd = sigma)
    y <- mu + epsilon
    # Run a regression
    mod <- lm(y ~ X)
    # Save the coefficients in a data frame
    # and Add a column indicating the simulation number
    mod_df <- tidy(mod) %>%
      mutate(.iter = j)
    mod_df[["std.error.robust"]] <- sqrt(diag(car::hccm(mod)))
    simulations[[j]] <- mod_df
    p$tick()$print()
  }
  bind_rows(simulations)
}
```

In these simulations, the population model is
$$
\begin{aligned}[t]
Y_i &= 0 + 1 \cdot x_1 + 1 \cdot x_2 \epsilon_i \\
\epsilon_i &\sim N(0, \sigma^2_i) \\
\log \sigma_i^2 &= 1.7 + \gamma_1 x_1 + 0 \cdot x_2
\end{aligned}
$$

We will run several simulations with different values of $\gamma_1$ to vary to heteroskedasticity: 

- $\gamma_1 = 0$ no heteroskedasticity
- $\gamma_1 = 0.2$ low
- $\gamma_1 = 0.7$ high

Before running the simulation draw a single sample of $y$ from a population with each of those values of $\gamma_1$.
You should be able to extract the relevant code from `sim_lin_norm_heterosked`.
Regress $y$ on $x_1$ and $x_2$ and plot the residuals of this regression against $x_1$.

Run `sim_lin_norm_heterosked` for each of those values of $\gamma_1$. 
How does heteroskedasticity affect

- the bias of each $\hat{\beta}_j$?
- the variance of $\hat{\beta}_j$?
- the bias of the standard error of each $\hat{\beta}_j$?
- the bias of the robust standard error of each $\hat{\beta}_j$?

Remember to consider how heteroskedasticity in $x_1$ affects the estimates of heteroskedasticity in $x_2$.

## Truncated Dependent Variable

This problem considers what happens when there is a truncated dependent variable.
This is also called sampling on the dependent variable, which is a research design problem not unknown to political science research.[^samplingdv]

The population is a linear normal model with homoskedastic errors.
$$
\begin{aligned}[t]
Y_1 &= \beta_0 + \beta_1 x_{1,i} + \dots + \beta_k x_{k,i} + \epsilon_i \\
\epsilon_i &\sim N(0, \sigma^2)
\end{aligned}
$$
However, in each sample, all $y_i$ which are less than a quantile $q$ are dropped before the regression is estimated.
$$
\begin{aligned}[t]
y_i = \beta_0 + \hat\beta_1 x_{1,i} + \dots + \hat\beta_k x_{k,i} + \hat\epsilon \\ \text{if $y_i \geq \quantile(y, q)$}
\end{aligned}
$$
where $\quantile(y, q)$ is the $q$th quantile of $y$.
For example, if $q = 0.5$, all $y_i$ that are less than the median of $y$ (the bottom 50%) are dropped.

The function `sim_lin_norm_trucated`, is similar to the `sim_lin_norm` function except for the argument

`truncation`

:    The quantile of truncation. All sampled $y_i$ with values less than that quantile are dropped before the regression is run.
     The default value `truncation = 0.5` means all values of $y$ less than the median are dropped before running the regression.


```{r}
sim_lin_norm_truncated <- function(m, n, mu_X, s_X, R_X, beta, sigma, truncation = 0.5) {
  X <- MASS::mvrnorm(n, mu_X, sdcor2cov(s_X, R_X), empirical = TRUE)
  simulations <- list()
  p <- progress_estimated(m, min_time = 2)
  for (j in 1:m) {
    mu <- cbind(1, X) %*% beta
    epsilon <- rnorm(n, mean = 0, sd = sigma)
    y <- mu + epsilon
    # -------
    # NEW: drop cases in which y > mean(y)
    is_obs <- (y < quantile(y, prob = truncation))
    yobs <- y[is_obs, ]
    Xobs <- X[is_obs, ]
    # -------
    # Run a regression
    mod <- lm(yobs ~ Xobs)
    # Save the coefficients in a data frame
    # and Add a column indicating the simulation number
    mod_df <- tidy(mod) %>%
      mutate(.iter = j)
    mod_df[["std.error.robust"]] <- sqrt(diag(car::hccm(mod)))
    simulations[[j]] <- mod_df
    p$tick()$print()
  }
  bind_rows(simulations)
}
``` 

For this problem, use only a single covariate, with $\mu_X = 0$,$s_X = 1$, and $R_X = 1$. 
Let $\beta = (0, 1)$ and $\sigma = 1$.

Before running simulations  with `sim_lin_normal_trunc`, 
write code to simulate a function from 

Run several simulations with `sim_lin_normal_trunc` and vary the sample size.
How does the sample size affect fhte following: 

- The bias of each $\hat{\beta}_j$?
- The variance of $\hat{\beta}_j$?
- The bias of the standard error of each $\hat{\beta}_j$?

In particular, does the effect of truncation on $\beta{\beta}$ decrease if we increase the sample size? 

## Serial Correlation (Optional)

**This problem you can do for fun.**
I had written this, but I think the homework may be getting a little long.
However, many of you are dealing with data in a panel format, this may be useful information. 
You will find that serial correlation is similar to heteroskedasticity in its effects on the estimates of OLS.

In this problem, we'll consider how serial correlation in errors and covariates affects OLS estimates.
Serial correlation in the errors means that the errors are correlated over time.
In this problem, the population we will use is
$$
Y_i = \beta_0 + \sum_{j = 1}^k \beta_j x_{j,i} + \epsilon_{i} + \rho \epsilon_{i - 1} 
$$
This is a moving average process of order 1, or MA(1).
If $\rho \neq 0$, then the $y_i$'s will be serially correlated.

Additionally, for each covariate, the present value will now depend on the random part of the previous value, such that,
$$
x_{k,i} = \mu_{x_k} + \rho_{x_k} \upsilon_{x_{k,i-1}} + \upsilon_{x_{k,i}} 
$$
This is a moving average of order 1, or MA(1). If $p_k \neq 0$ for some $k$, that $x_k$ is also serially correlated.

However, the regression run on each sample will be an OLS regression that does not attempt to account for serial correlation,
$$
y_i = \hat\beta_0 + \hat\beta_1 x_{}
$$

The function `sim_lin_norm_ma`

`rho`

:   A value between 0 and 1 determining the serial correlation of the errors.

`rho_X`

:   A value between 0 and 1 determining the serial correlation of the covariates in $X$.
    This assumes that the serial correlation in all $X$ is the same.

```{r}
sim_lin_norm_ma1 <- function(m, n, mu_X, s_X, R_X, beta, sigma,
                             rho = 0.5, rho_X = 0) {
  assert_that(length(s_X) == length(mu_X),
              ncol(R_X) == nrow(R_X),
              ncol(R_X) == length(mu_X),
              length(beta) == (length(mu_X) + 1),
              length(rho_X) == length(mu_X),
              all(rho >= 0 & rho <= 1),
              all(rho_X >= 0 & rho_X <= 1))
  k <- length(mu_X)
  X <- mvrnorm_ma(n, mu_X, sdcor2cov(s_X, R_X), rho = rho_X, empirical = TRUE)
  simulations <- list()
  p <- progress_estimated(m, min_time = 2)
  for (j in 1:m) {
    mu <- cbind(1, X) %*% beta
    # ---------
    # NEW: generate y with serially correlated errors
    lag_epsilson <- rep(0, k)
    for (i in 1:n) {
      epsilon <- rnorm(1, mean = 0, sd = sigma)
      y <- mu[i, ] + rho * lag_epsilon + epsilon
      lag_epsilon <- epsilon
    }
    # ---------
    mod <- lm(y ~ X)
    mod_df <- tidy(mod) %>%
      mutate(.iter = j)
    mod_df[["std.error.robust"]] <- sqrt(diag(car::hccm(mod)))
    simulations[[j]] <- mod_df
    p$tick()$print()
  }
  # Combine the list of data frames into a single data frame
  bind_rows(simulations)
}
```

In these simulations, the population model is
$$
\begin{aligned}[t]
Y_i &= 0 + 1 \cdot x_1 + 1 \cdot x_2 + 1 \cdot x_3 + \epsilon_i + \rho \epsilon_{i - 1} \\
\epsilon_i &\sim N(0, \sigma^2) \\
\sigma^2 &= 1.7 \\
\epsilon_{0} &= 0
\end{aligned}
$$
where $\rho$ will vary with simulations.
The covariates $x$ are drawn from 
$$
\begin{aligned}[t]
x_{j,i} &= 0 + \upsilon_{j,i} + \rho_{X,j} \upsilon_{j,i} & \text{for $j = 1, 2, 3$} \\
\upsilon &= N(0, I_3) \\
\rho_{X} &= (0, 0.5, 0.9) \\
\upsilon_0 &= 0
\end{aligned}
$$
Thus $x_1$ has no serial correlation, $x_2$ has moderate serial correlation, and $x_3$ has high serial correlation.

Compare the bias and variance of $\hat{\beta}$ under the following scenarios.

- $\rho = 0$, no serial correlation in the errors of $y$.
- $\rho = 0.5$, moderate serial correlation in the errors of $y$
- $\rho = 0.9$, high serial correlation in the error of $y$.

How does serial correlation in $y$ and $X$ influence OLS estimates?
Consider bias and variance of the estimates of $\hat\beta$. 
Also consider the bias of the standard error of $\hat\beta$.
Does using robust standard errors help?

[^randomx]: Although the statistical theory of OLS works (thankfully) for random $X$,
    as long as certain conditions are met. See Fox (2nd ed.), Ch 9.6. 
 
[^samplingdv]: See Ashworth, Scott, Joshua D. Clinton, Adam Meirowitz, and Kristopher W. Ramsay. 2008. ``Design, Inference, and the Strategic Logic of Suicide Terrorism.'' *American Political Science Review() 102(02): 269â€“73. <http://journals.cambridge.org/article_S0003055408080167>

* * *

Derived from of Christopher Adolph, "Problem Set 3", *POLS/CSSS 503*, University of Washington, Spring 2014. <http://faculty.washington.edu/cadolph/503/503hw3.pdf>. Used with permission.

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
